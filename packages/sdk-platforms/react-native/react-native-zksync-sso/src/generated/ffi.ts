// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
  type UniffiVTableCallbackInterfacePasskeyAuthenticator,
  type UniffiVTableCallbackInterfacePasskeyAuthenticatorAsync,
} from './ffi-ffi';
import {
  type FfiConverter,
  type UniffiByteArray,
  type UniffiHandle,
  type UniffiObjectFactory,
  type UniffiReferenceHolder,
  type UniffiRustArcPtr,
  type UniffiRustCallStatus,
  type UnsafeMutableRawPointer,
  AbstractFfiConverterByteArray,
  FfiConverterArrayBuffer,
  FfiConverterInt32,
  FfiConverterObject,
  FfiConverterObjectWithCallbacks,
  FfiConverterUInt64,
  RustBuffer,
  UniffiAbstractObject,
  UniffiError,
  UniffiInternalError,
  UniffiResult,
  UniffiRustCaller,
  destructorGuardSymbol,
  pointerLiteralSymbol,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiRustCallAsync,
  uniffiTraitInterfaceCallAsyncWithError,
  uniffiTraitInterfaceCallWithError,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller();

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

export async function deployAccount(
  passkeyParameters: PasskeyParameters,
  config: Config,
  asyncOpts_?: { signal: AbortSignal }
): Promise<Account> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_ffi_fn_func_deploy_account(
          FfiConverterTypePasskeyParameters.lower(passkeyParameters),
          FfiConverterTypeConfig.lower(config)
        );
      },
      /*pollFunc:*/ nativeModule().ubrn_ffi_ffi_rust_future_poll_rust_buffer,
      /*cancelFunc:*/ nativeModule()
        .ubrn_ffi_ffi_rust_future_cancel_rust_buffer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_ffi_rust_future_complete_rust_buffer,
      /*freeFunc:*/ nativeModule().ubrn_ffi_ffi_rust_future_free_rust_buffer,
      /*liftFunc:*/ FfiConverterTypeAccount.lift.bind(FfiConverterTypeAccount),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeDeployAccountError.lift.bind(
        FfiConverterTypeDeployAccountError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
export async function deployAccountWithUniqueId(
  passkeyParameters: PasskeyParameters,
  uniqueAccountId: string,
  secretAccountSalt: string,
  config: Config,
  asyncOpts_?: { signal: AbortSignal }
): Promise<Account> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_ffi_fn_func_deploy_account_with_unique_id(
          FfiConverterTypePasskeyParameters.lower(passkeyParameters),
          FfiConverterString.lower(uniqueAccountId),
          FfiConverterString.lower(secretAccountSalt),
          FfiConverterTypeConfig.lower(config)
        );
      },
      /*pollFunc:*/ nativeModule().ubrn_ffi_ffi_rust_future_poll_rust_buffer,
      /*cancelFunc:*/ nativeModule()
        .ubrn_ffi_ffi_rust_future_cancel_rust_buffer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_ffi_rust_future_complete_rust_buffer,
      /*freeFunc:*/ nativeModule().ubrn_ffi_ffi_rust_future_free_rust_buffer,
      /*liftFunc:*/ FfiConverterTypeAccount.lift.bind(FfiConverterTypeAccount),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeDeployAccountError.lift.bind(
        FfiConverterTypeDeployAccountError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
export async function fetchAccount(
  uniqueAccountId: string,
  expectedOrigin: string,
  config: Config,
  asyncOpts_?: { signal: AbortSignal }
): Promise<Account> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_ffi_fn_func_fetch_account(
          FfiConverterString.lower(uniqueAccountId),
          FfiConverterString.lower(expectedOrigin),
          FfiConverterTypeConfig.lower(config)
        );
      },
      /*pollFunc:*/ nativeModule().ubrn_ffi_ffi_rust_future_poll_rust_buffer,
      /*cancelFunc:*/ nativeModule()
        .ubrn_ffi_ffi_rust_future_cancel_rust_buffer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_ffi_rust_future_complete_rust_buffer,
      /*freeFunc:*/ nativeModule().ubrn_ffi_ffi_rust_future_free_rust_buffer,
      /*liftFunc:*/ FfiConverterTypeAccount.lift.bind(FfiConverterTypeAccount),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeFetchAccountError.lift.bind(
        FfiConverterTypeFetchAccountError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
export async function fundAccount(
  address: string,
  config: Config,
  asyncOpts_?: { signal: AbortSignal }
): Promise<void> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_ffi_fn_func_fund_account(
          FfiConverterString.lower(address),
          FfiConverterTypeConfig.lower(config)
        );
      },
      /*pollFunc:*/ nativeModule().ubrn_ffi_ffi_rust_future_poll_void,
      /*cancelFunc:*/ nativeModule().ubrn_ffi_ffi_rust_future_cancel_void,
      /*completeFunc:*/ nativeModule().ubrn_ffi_ffi_rust_future_complete_void,
      /*freeFunc:*/ nativeModule().ubrn_ffi_ffi_rust_future_free_void,
      /*liftFunc:*/ (_v) => {},
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeFundAccountError.lift.bind(
        FfiConverterTypeFundAccountError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
export function generateRandomChallenge(): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_ffi_fn_func_generate_random_challenge(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export async function getAccountByUserId(
  uniqueAccountId: string,
  secretAccountSalt: string,
  config: Config,
  asyncOpts_?: { signal: AbortSignal }
): Promise<Account> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_ffi_fn_func_get_account_by_user_id(
          FfiConverterString.lower(uniqueAccountId),
          FfiConverterString.lower(secretAccountSalt),
          FfiConverterTypeConfig.lower(config)
        );
      },
      /*pollFunc:*/ nativeModule().ubrn_ffi_ffi_rust_future_poll_rust_buffer,
      /*cancelFunc:*/ nativeModule()
        .ubrn_ffi_ffi_rust_future_cancel_rust_buffer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_ffi_rust_future_complete_rust_buffer,
      /*freeFunc:*/ nativeModule().ubrn_ffi_ffi_rust_future_free_rust_buffer,
      /*liftFunc:*/ FfiConverterTypeAccount.lift.bind(FfiConverterTypeAccount),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeFetchAccountError.lift.bind(
        FfiConverterTypeFetchAccountError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
export async function getBalance(
  address: string,
  config: Config,
  asyncOpts_?: { signal: AbortSignal }
): Promise<AccountBalance> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_ffi_fn_func_get_balance(
          FfiConverterString.lower(address),
          FfiConverterTypeConfig.lower(config)
        );
      },
      /*pollFunc:*/ nativeModule().ubrn_ffi_ffi_rust_future_poll_rust_buffer,
      /*cancelFunc:*/ nativeModule()
        .ubrn_ffi_ffi_rust_future_cancel_rust_buffer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_ffi_rust_future_complete_rust_buffer,
      /*freeFunc:*/ nativeModule().ubrn_ffi_ffi_rust_future_free_rust_buffer,
      /*liftFunc:*/ FfiConverterTypeAccountBalance.lift.bind(
        FfiConverterTypeAccountBalance
      ),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeGetAccountBalanceError.lift.bind(
        FfiConverterTypeGetAccountBalanceError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
export async function prepareSendTransaction(
  transaction: Transaction,
  from: string,
  config: Config,
  asyncOpts_?: { signal: AbortSignal }
): Promise<PreparedTransaction> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_ffi_fn_func_prepare_send_transaction(
          FfiConverterTypeTransaction.lower(transaction),
          FfiConverterString.lower(from),
          FfiConverterTypeConfig.lower(config)
        );
      },
      /*pollFunc:*/ nativeModule().ubrn_ffi_ffi_rust_future_poll_rust_buffer,
      /*cancelFunc:*/ nativeModule()
        .ubrn_ffi_ffi_rust_future_cancel_rust_buffer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_ffi_rust_future_complete_rust_buffer,
      /*freeFunc:*/ nativeModule().ubrn_ffi_ffi_rust_future_free_rust_buffer,
      /*liftFunc:*/ FfiConverterTypePreparedTransaction.lift.bind(
        FfiConverterTypePreparedTransaction
      ),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypePrepareTransactionError.lift.bind(
        FfiConverterTypePrepareTransactionError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
export async function sendTransaction(
  transaction: Transaction,
  authenticator: PasskeyAuthenticator,
  config: Config,
  asyncOpts_?: { signal: AbortSignal }
): Promise<SendTransactionResult> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_ffi_fn_func_send_transaction(
          FfiConverterTypeTransaction.lower(transaction),
          FfiConverterTypePasskeyAuthenticator.lower(authenticator),
          FfiConverterTypeConfig.lower(config)
        );
      },
      /*pollFunc:*/ nativeModule().ubrn_ffi_ffi_rust_future_poll_rust_buffer,
      /*cancelFunc:*/ nativeModule()
        .ubrn_ffi_ffi_rust_future_cancel_rust_buffer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_ffi_rust_future_complete_rust_buffer,
      /*freeFunc:*/ nativeModule().ubrn_ffi_ffi_rust_future_free_rust_buffer,
      /*liftFunc:*/ FfiConverterTypeSendTransactionResult.lift.bind(
        FfiConverterTypeSendTransactionResult
      ),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeSendTransactionError.lift.bind(
        FfiConverterTypeSendTransactionError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}
export async function sendTransactionAsyncSigner(
  transaction: Transaction,
  authenticator: PasskeyAuthenticatorAsync,
  config: Config,
  asyncOpts_?: { signal: AbortSignal }
): Promise<SendTransactionResult> /*throws*/ {
  const __stack = uniffiIsDebug ? new Error().stack : undefined;
  try {
    return await uniffiRustCallAsync(
      /*rustCaller:*/ uniffiCaller,
      /*rustFutureFunc:*/ () => {
        return nativeModule().ubrn_uniffi_ffi_fn_func_send_transaction_async_signer(
          FfiConverterTypeTransaction.lower(transaction),
          FfiConverterTypePasskeyAuthenticatorAsync.lower(authenticator),
          FfiConverterTypeConfig.lower(config)
        );
      },
      /*pollFunc:*/ nativeModule().ubrn_ffi_ffi_rust_future_poll_rust_buffer,
      /*cancelFunc:*/ nativeModule()
        .ubrn_ffi_ffi_rust_future_cancel_rust_buffer,
      /*completeFunc:*/ nativeModule()
        .ubrn_ffi_ffi_rust_future_complete_rust_buffer,
      /*freeFunc:*/ nativeModule().ubrn_ffi_ffi_rust_future_free_rust_buffer,
      /*liftFunc:*/ FfiConverterTypeSendTransactionResult.lift.bind(
        FfiConverterTypeSendTransactionResult
      ),
      /*liftString:*/ FfiConverterString.lift,
      /*asyncOpts:*/ asyncOpts_,
      /*errorHandler:*/ FfiConverterTypeSendTransactionError.lift.bind(
        FfiConverterTypeSendTransactionError
      )
    );
  } catch (__error: any) {
    if (uniffiIsDebug && __error instanceof Error) {
      __error.stack = __stack;
    }
    throw __error;
  }
}

export type Account = {
  address: string;
  uniqueAccountId: string;
};

/**
 * Generated factory for {@link Account} record objects.
 */
export const Account = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Account, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Account}, with defaults specified
     * in Rust, in the {@link ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Account}, with defaults specified
     * in Rust, in the {@link ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Account>,
  });
})();

const FfiConverterTypeAccount = (() => {
  type TypeName = Account;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        address: FfiConverterString.read(from),
        uniqueAccountId: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.address, into);
      FfiConverterString.write(value.uniqueAccountId, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.address) +
        FfiConverterString.allocationSize(value.uniqueAccountId)
      );
    }
  }
  return new FFIConverter();
})();

export type AccountBalance = {
  balance: string;
};

/**
 * Generated factory for {@link AccountBalance} record objects.
 */
export const AccountBalance = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<AccountBalance, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link AccountBalance}, with defaults specified
     * in Rust, in the {@link ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link AccountBalance}, with defaults specified
     * in Rust, in the {@link ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<AccountBalance>,
  });
})();

const FfiConverterTypeAccountBalance = (() => {
  type TypeName = AccountBalance;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        balance: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.balance, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterString.allocationSize(value.balance);
    }
  }
  return new FFIConverter();
})();

export type Config = {
  contracts: PasskeyContracts;
  nodeUrl: string;
};

/**
 * Generated factory for {@link Config} record objects.
 */
export const Config = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Config, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Config}, with defaults specified
     * in Rust, in the {@link ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Config}, with defaults specified
     * in Rust, in the {@link ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Config>,
  });
})();

const FfiConverterTypeConfig = (() => {
  type TypeName = Config;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        contracts: FfiConverterTypePasskeyContracts.read(from),
        nodeUrl: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypePasskeyContracts.write(value.contracts, into);
      FfiConverterString.write(value.nodeUrl, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypePasskeyContracts.allocationSize(value.contracts) +
        FfiConverterString.allocationSize(value.nodeUrl)
      );
    }
  }
  return new FFIConverter();
})();

export type PasskeyContracts = {
  accountFactory: string;
  passkey: string;
  session: string;
  accountPaymaster: string;
};

/**
 * Generated factory for {@link PasskeyContracts} record objects.
 */
export const PasskeyContracts = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PasskeyContracts, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PasskeyContracts}, with defaults specified
     * in Rust, in the {@link ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PasskeyContracts}, with defaults specified
     * in Rust, in the {@link ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PasskeyContracts>,
  });
})();

const FfiConverterTypePasskeyContracts = (() => {
  type TypeName = PasskeyContracts;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        accountFactory: FfiConverterString.read(from),
        passkey: FfiConverterString.read(from),
        session: FfiConverterString.read(from),
        accountPaymaster: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.accountFactory, into);
      FfiConverterString.write(value.passkey, into);
      FfiConverterString.write(value.session, into);
      FfiConverterString.write(value.accountPaymaster, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.accountFactory) +
        FfiConverterString.allocationSize(value.passkey) +
        FfiConverterString.allocationSize(value.session) +
        FfiConverterString.allocationSize(value.accountPaymaster)
      );
    }
  }
  return new FFIConverter();
})();

export type PasskeyParameters = {
  credentialRawAttestationObject: ArrayBuffer;
  credentialRawClientDataJson: ArrayBuffer;
  credentialId: ArrayBuffer;
  rpId: string;
};

/**
 * Generated factory for {@link PasskeyParameters} record objects.
 */
export const PasskeyParameters = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PasskeyParameters, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PasskeyParameters}, with defaults specified
     * in Rust, in the {@link ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PasskeyParameters}, with defaults specified
     * in Rust, in the {@link ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PasskeyParameters>,
  });
})();

const FfiConverterTypePasskeyParameters = (() => {
  type TypeName = PasskeyParameters;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        credentialRawAttestationObject: FfiConverterArrayBuffer.read(from),
        credentialRawClientDataJson: FfiConverterArrayBuffer.read(from),
        credentialId: FfiConverterArrayBuffer.read(from),
        rpId: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayBuffer.write(value.credentialRawAttestationObject, into);
      FfiConverterArrayBuffer.write(value.credentialRawClientDataJson, into);
      FfiConverterArrayBuffer.write(value.credentialId, into);
      FfiConverterString.write(value.rpId, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayBuffer.allocationSize(
          value.credentialRawAttestationObject
        ) +
        FfiConverterArrayBuffer.allocationSize(
          value.credentialRawClientDataJson
        ) +
        FfiConverterArrayBuffer.allocationSize(value.credentialId) +
        FfiConverterString.allocationSize(value.rpId)
      );
    }
  }
  return new FFIConverter();
})();

export type PreparedTransaction = {
  transactionRequestJson: string;
  from: string;
  to: string;
  value: string;
  displayFee: string;
};

/**
 * Generated factory for {@link PreparedTransaction} record objects.
 */
export const PreparedTransaction = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PreparedTransaction, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PreparedTransaction}, with defaults specified
     * in Rust, in the {@link ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PreparedTransaction}, with defaults specified
     * in Rust, in the {@link ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PreparedTransaction>,
  });
})();

const FfiConverterTypePreparedTransaction = (() => {
  type TypeName = PreparedTransaction;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        transactionRequestJson: FfiConverterString.read(from),
        from: FfiConverterString.read(from),
        to: FfiConverterString.read(from),
        value: FfiConverterString.read(from),
        displayFee: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.transactionRequestJson, into);
      FfiConverterString.write(value.from, into);
      FfiConverterString.write(value.to, into);
      FfiConverterString.write(value.value, into);
      FfiConverterString.write(value.displayFee, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.transactionRequestJson) +
        FfiConverterString.allocationSize(value.from) +
        FfiConverterString.allocationSize(value.to) +
        FfiConverterString.allocationSize(value.value) +
        FfiConverterString.allocationSize(value.displayFee)
      );
    }
  }
  return new FFIConverter();
})();

export type SendTransactionResult = {
  txHash: string;
  receiptJson: string;
};

/**
 * Generated factory for {@link SendTransactionResult} record objects.
 */
export const SendTransactionResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      SendTransactionResult,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link SendTransactionResult}, with defaults specified
     * in Rust, in the {@link ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link SendTransactionResult}, with defaults specified
     * in Rust, in the {@link ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<SendTransactionResult>,
  });
})();

const FfiConverterTypeSendTransactionResult = (() => {
  type TypeName = SendTransactionResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        txHash: FfiConverterString.read(from),
        receiptJson: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.txHash, into);
      FfiConverterString.write(value.receiptJson, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.txHash) +
        FfiConverterString.allocationSize(value.receiptJson)
      );
    }
  }
  return new FFIConverter();
})();

export type Transaction = {
  to: string;
  value: string;
  from: string;
};

/**
 * Generated factory for {@link Transaction} record objects.
 */
export const Transaction = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Transaction, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Transaction}, with defaults specified
     * in Rust, in the {@link ffi} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Transaction}, with defaults specified
     * in Rust, in the {@link ffi} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link ffi} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Transaction>,
  });
})();

const FfiConverterTypeTransaction = (() => {
  type TypeName = Transaction;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        to: FfiConverterString.read(from),
        value: FfiConverterString.read(from),
        from: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.to, into);
      FfiConverterString.write(value.value, into);
      FfiConverterString.write(value.from, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.to) +
        FfiConverterString.allocationSize(value.value) +
        FfiConverterString.allocationSize(value.from)
      );
    }
  }
  return new FFIConverter();
})();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status
      )
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status
      )
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status
      )
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

// Error type: ConfigError

// Enum: ConfigError
export enum ConfigError_Tags {
  InvalidContractAddress = 'InvalidContractAddress',
  InvalidNodeUrl = 'InvalidNodeUrl',
  WriteError = 'WriteError',
}
export const ConfigError = (() => {
  type InvalidContractAddress__interface = {
    tag: ConfigError_Tags.InvalidContractAddress;
    inner: Readonly<[string]>;
  };

  class InvalidContractAddress_
    extends UniffiError
    implements InvalidContractAddress__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ConfigError';
    readonly tag = ConfigError_Tags.InvalidContractAddress;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ConfigError', 'InvalidContractAddress');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): InvalidContractAddress_ {
      return new InvalidContractAddress_(v0);
    }

    static instanceOf(obj: any): obj is InvalidContractAddress_ {
      return obj.tag === ConfigError_Tags.InvalidContractAddress;
    }

    static hasInner(obj: any): obj is InvalidContractAddress_ {
      return InvalidContractAddress_.instanceOf(obj);
    }

    static getInner(obj: InvalidContractAddress_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type InvalidNodeUrl__interface = {
    tag: ConfigError_Tags.InvalidNodeUrl;
    inner: Readonly<[string]>;
  };

  class InvalidNodeUrl_
    extends UniffiError
    implements InvalidNodeUrl__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ConfigError';
    readonly tag = ConfigError_Tags.InvalidNodeUrl;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ConfigError', 'InvalidNodeUrl');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): InvalidNodeUrl_ {
      return new InvalidNodeUrl_(v0);
    }

    static instanceOf(obj: any): obj is InvalidNodeUrl_ {
      return obj.tag === ConfigError_Tags.InvalidNodeUrl;
    }

    static hasInner(obj: any): obj is InvalidNodeUrl_ {
      return InvalidNodeUrl_.instanceOf(obj);
    }

    static getInner(obj: InvalidNodeUrl_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type WriteError__interface = {
    tag: ConfigError_Tags.WriteError;
    inner: Readonly<[string]>;
  };

  class WriteError_ extends UniffiError implements WriteError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ConfigError';
    readonly tag = ConfigError_Tags.WriteError;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('ConfigError', 'WriteError');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): WriteError_ {
      return new WriteError_(v0);
    }

    static instanceOf(obj: any): obj is WriteError_ {
      return obj.tag === ConfigError_Tags.WriteError;
    }

    static hasInner(obj: any): obj is WriteError_ {
      return WriteError_.instanceOf(obj);
    }

    static getInner(obj: WriteError_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is ConfigError {
    return obj[uniffiTypeNameSymbol] === 'ConfigError';
  }

  return Object.freeze({
    instanceOf,
    InvalidContractAddress: InvalidContractAddress_,
    InvalidNodeUrl: InvalidNodeUrl_,
    WriteError: WriteError_,
  });
})();

export type ConfigError = InstanceType<
  (typeof ConfigError)[keyof Omit<typeof ConfigError, 'instanceOf'>]
>;

// FfiConverter for enum ConfigError
const FfiConverterTypeConfigError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ConfigError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ConfigError.InvalidContractAddress(
            FfiConverterString.read(from)
          );
        case 2:
          return new ConfigError.InvalidNodeUrl(FfiConverterString.read(from));
        case 3:
          return new ConfigError.WriteError(FfiConverterString.read(from));
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ConfigError_Tags.InvalidContractAddress: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case ConfigError_Tags.InvalidNodeUrl: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case ConfigError_Tags.WriteError: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that ConfigError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ConfigError_Tags.InvalidContractAddress: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case ConfigError_Tags.InvalidNodeUrl: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case ConfigError_Tags.WriteError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: DeployAccountError

// Enum: DeployAccountError
export enum DeployAccountError_Tags {
  Deploy = 'Deploy',
  AccountAlreadyDeployed = 'AccountAlreadyDeployed',
}
export const DeployAccountError = (() => {
  type Deploy__interface = {
    tag: DeployAccountError_Tags.Deploy;
    inner: Readonly<[string]>;
  };

  class Deploy_ extends UniffiError implements Deploy__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'DeployAccountError';
    readonly tag = DeployAccountError_Tags.Deploy;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('DeployAccountError', 'Deploy');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Deploy_ {
      return new Deploy_(v0);
    }

    static instanceOf(obj: any): obj is Deploy_ {
      return obj.tag === DeployAccountError_Tags.Deploy;
    }

    static hasInner(obj: any): obj is Deploy_ {
      return Deploy_.instanceOf(obj);
    }

    static getInner(obj: Deploy_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type AccountAlreadyDeployed__interface = {
    tag: DeployAccountError_Tags.AccountAlreadyDeployed;
  };

  class AccountAlreadyDeployed_
    extends UniffiError
    implements AccountAlreadyDeployed__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'DeployAccountError';
    readonly tag = DeployAccountError_Tags.AccountAlreadyDeployed;
    constructor() {
      super('DeployAccountError', 'AccountAlreadyDeployed');
    }

    static new(): AccountAlreadyDeployed_ {
      return new AccountAlreadyDeployed_();
    }

    static instanceOf(obj: any): obj is AccountAlreadyDeployed_ {
      return obj.tag === DeployAccountError_Tags.AccountAlreadyDeployed;
    }

    static hasInner(obj: any): obj is AccountAlreadyDeployed_ {
      return false;
    }
  }

  function instanceOf(obj: any): obj is DeployAccountError {
    return obj[uniffiTypeNameSymbol] === 'DeployAccountError';
  }

  return Object.freeze({
    instanceOf,
    Deploy: Deploy_,
    AccountAlreadyDeployed: AccountAlreadyDeployed_,
  });
})();

export type DeployAccountError = InstanceType<
  (typeof DeployAccountError)[keyof Omit<
    typeof DeployAccountError,
    'instanceOf'
  >]
>;

// FfiConverter for enum DeployAccountError
const FfiConverterTypeDeployAccountError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = DeployAccountError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new DeployAccountError.Deploy(FfiConverterString.read(from));
        case 2:
          return new DeployAccountError.AccountAlreadyDeployed();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case DeployAccountError_Tags.Deploy: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case DeployAccountError_Tags.AccountAlreadyDeployed: {
          ordinalConverter.write(2, into);
          return;
        }
        default:
          // Throwing from here means that DeployAccountError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case DeployAccountError_Tags.Deploy: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case DeployAccountError_Tags.AccountAlreadyDeployed: {
          return ordinalConverter.allocationSize(2);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: FetchAccountError

// Enum: FetchAccountError
export enum FetchAccountError_Tags {
  FetchAccount = 'FetchAccount',
}
export const FetchAccountError = (() => {
  type FetchAccount__interface = {
    tag: FetchAccountError_Tags.FetchAccount;
    inner: Readonly<[string]>;
  };

  class FetchAccount_ extends UniffiError implements FetchAccount__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FetchAccountError';
    readonly tag = FetchAccountError_Tags.FetchAccount;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('FetchAccountError', 'FetchAccount');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): FetchAccount_ {
      return new FetchAccount_(v0);
    }

    static instanceOf(obj: any): obj is FetchAccount_ {
      return obj.tag === FetchAccountError_Tags.FetchAccount;
    }

    static hasInner(obj: any): obj is FetchAccount_ {
      return FetchAccount_.instanceOf(obj);
    }

    static getInner(obj: FetchAccount_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is FetchAccountError {
    return obj[uniffiTypeNameSymbol] === 'FetchAccountError';
  }

  return Object.freeze({
    instanceOf,
    FetchAccount: FetchAccount_,
  });
})();

export type FetchAccountError = InstanceType<
  (typeof FetchAccountError)[keyof Omit<typeof FetchAccountError, 'instanceOf'>]
>;

// FfiConverter for enum FetchAccountError
const FfiConverterTypeFetchAccountError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FetchAccountError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new FetchAccountError.FetchAccount(
            FfiConverterString.read(from)
          );
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case FetchAccountError_Tags.FetchAccount: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that FetchAccountError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case FetchAccountError_Tags.FetchAccount: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: FundAccountError

// Enum: FundAccountError
export enum FundAccountError_Tags {
  FundAccount = 'FundAccount',
}
export const FundAccountError = (() => {
  type FundAccount__interface = {
    tag: FundAccountError_Tags.FundAccount;
    inner: Readonly<[string]>;
  };

  class FundAccount_ extends UniffiError implements FundAccount__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FundAccountError';
    readonly tag = FundAccountError_Tags.FundAccount;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('FundAccountError', 'FundAccount');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): FundAccount_ {
      return new FundAccount_(v0);
    }

    static instanceOf(obj: any): obj is FundAccount_ {
      return obj.tag === FundAccountError_Tags.FundAccount;
    }

    static hasInner(obj: any): obj is FundAccount_ {
      return FundAccount_.instanceOf(obj);
    }

    static getInner(obj: FundAccount_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is FundAccountError {
    return obj[uniffiTypeNameSymbol] === 'FundAccountError';
  }

  return Object.freeze({
    instanceOf,
    FundAccount: FundAccount_,
  });
})();

export type FundAccountError = InstanceType<
  (typeof FundAccountError)[keyof Omit<typeof FundAccountError, 'instanceOf'>]
>;

// FfiConverter for enum FundAccountError
const FfiConverterTypeFundAccountError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FundAccountError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new FundAccountError.FundAccount(
            FfiConverterString.read(from)
          );
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case FundAccountError_Tags.FundAccount: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that FundAccountError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case FundAccountError_Tags.FundAccount: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: GetAccountBalanceError

// Enum: GetAccountBalanceError
export enum GetAccountBalanceError_Tags {
  GetBalance = 'GetBalance',
}
export const GetAccountBalanceError = (() => {
  type GetBalance__interface = {
    tag: GetAccountBalanceError_Tags.GetBalance;
    inner: Readonly<[string]>;
  };

  class GetBalance_ extends UniffiError implements GetBalance__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'GetAccountBalanceError';
    readonly tag = GetAccountBalanceError_Tags.GetBalance;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('GetAccountBalanceError', 'GetBalance');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): GetBalance_ {
      return new GetBalance_(v0);
    }

    static instanceOf(obj: any): obj is GetBalance_ {
      return obj.tag === GetAccountBalanceError_Tags.GetBalance;
    }

    static hasInner(obj: any): obj is GetBalance_ {
      return GetBalance_.instanceOf(obj);
    }

    static getInner(obj: GetBalance_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is GetAccountBalanceError {
    return obj[uniffiTypeNameSymbol] === 'GetAccountBalanceError';
  }

  return Object.freeze({
    instanceOf,
    GetBalance: GetBalance_,
  });
})();

export type GetAccountBalanceError = InstanceType<
  (typeof GetAccountBalanceError)[keyof Omit<
    typeof GetAccountBalanceError,
    'instanceOf'
  >]
>;

// FfiConverter for enum GetAccountBalanceError
const FfiConverterTypeGetAccountBalanceError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = GetAccountBalanceError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new GetAccountBalanceError.GetBalance(
            FfiConverterString.read(from)
          );
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case GetAccountBalanceError_Tags.GetBalance: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that GetAccountBalanceError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case GetAccountBalanceError_Tags.GetBalance: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: PasskeyAuthenticatorError

// Enum: PasskeyAuthenticatorError
export enum PasskeyAuthenticatorError_Tags {
  Get = 'Get',
}
export const PasskeyAuthenticatorError = (() => {
  type Get__interface = {
    tag: PasskeyAuthenticatorError_Tags.Get;
    inner: Readonly<[string]>;
  };

  class Get_ extends UniffiError implements Get__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PasskeyAuthenticatorError';
    readonly tag = PasskeyAuthenticatorError_Tags.Get;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('PasskeyAuthenticatorError', 'Get');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Get_ {
      return new Get_(v0);
    }

    static instanceOf(obj: any): obj is Get_ {
      return obj.tag === PasskeyAuthenticatorError_Tags.Get;
    }

    static hasInner(obj: any): obj is Get_ {
      return Get_.instanceOf(obj);
    }

    static getInner(obj: Get_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is PasskeyAuthenticatorError {
    return obj[uniffiTypeNameSymbol] === 'PasskeyAuthenticatorError';
  }

  return Object.freeze({
    instanceOf,
    Get: Get_,
  });
})();

export type PasskeyAuthenticatorError = InstanceType<
  (typeof PasskeyAuthenticatorError)[keyof Omit<
    typeof PasskeyAuthenticatorError,
    'instanceOf'
  >]
>;

// FfiConverter for enum PasskeyAuthenticatorError
const FfiConverterTypePasskeyAuthenticatorError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PasskeyAuthenticatorError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new PasskeyAuthenticatorError.Get(
            FfiConverterString.read(from)
          );
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case PasskeyAuthenticatorError_Tags.Get: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that PasskeyAuthenticatorError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case PasskeyAuthenticatorError_Tags.Get: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: PrepareTransactionError

// Enum: PrepareTransactionError
export enum PrepareTransactionError_Tags {
  PrepareTransaction = 'PrepareTransaction',
  InvalidAddress = 'InvalidAddress',
}
export const PrepareTransactionError = (() => {
  type PrepareTransaction__interface = {
    tag: PrepareTransactionError_Tags.PrepareTransaction;
    inner: Readonly<[string]>;
  };

  class PrepareTransaction_
    extends UniffiError
    implements PrepareTransaction__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PrepareTransactionError';
    readonly tag = PrepareTransactionError_Tags.PrepareTransaction;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('PrepareTransactionError', 'PrepareTransaction');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): PrepareTransaction_ {
      return new PrepareTransaction_(v0);
    }

    static instanceOf(obj: any): obj is PrepareTransaction_ {
      return obj.tag === PrepareTransactionError_Tags.PrepareTransaction;
    }

    static hasInner(obj: any): obj is PrepareTransaction_ {
      return PrepareTransaction_.instanceOf(obj);
    }

    static getInner(obj: PrepareTransaction_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type InvalidAddress__interface = {
    tag: PrepareTransactionError_Tags.InvalidAddress;
    inner: Readonly<[string]>;
  };

  class InvalidAddress_
    extends UniffiError
    implements InvalidAddress__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'PrepareTransactionError';
    readonly tag = PrepareTransactionError_Tags.InvalidAddress;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('PrepareTransactionError', 'InvalidAddress');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): InvalidAddress_ {
      return new InvalidAddress_(v0);
    }

    static instanceOf(obj: any): obj is InvalidAddress_ {
      return obj.tag === PrepareTransactionError_Tags.InvalidAddress;
    }

    static hasInner(obj: any): obj is InvalidAddress_ {
      return InvalidAddress_.instanceOf(obj);
    }

    static getInner(obj: InvalidAddress_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is PrepareTransactionError {
    return obj[uniffiTypeNameSymbol] === 'PrepareTransactionError';
  }

  return Object.freeze({
    instanceOf,
    PrepareTransaction: PrepareTransaction_,
    InvalidAddress: InvalidAddress_,
  });
})();

export type PrepareTransactionError = InstanceType<
  (typeof PrepareTransactionError)[keyof Omit<
    typeof PrepareTransactionError,
    'instanceOf'
  >]
>;

// FfiConverter for enum PrepareTransactionError
const FfiConverterTypePrepareTransactionError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PrepareTransactionError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new PrepareTransactionError.PrepareTransaction(
            FfiConverterString.read(from)
          );
        case 2:
          return new PrepareTransactionError.InvalidAddress(
            FfiConverterString.read(from)
          );
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case PrepareTransactionError_Tags.PrepareTransaction: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case PrepareTransactionError_Tags.InvalidAddress: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that PrepareTransactionError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case PrepareTransactionError_Tags.PrepareTransaction: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case PrepareTransactionError_Tags.InvalidAddress: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: SendTransactionError

// Enum: SendTransactionError
export enum SendTransactionError_Tags {
  SendTransaction = 'SendTransaction',
  InvalidAddress = 'InvalidAddress',
}
export const SendTransactionError = (() => {
  type SendTransaction__interface = {
    tag: SendTransactionError_Tags.SendTransaction;
    inner: Readonly<[string]>;
  };

  class SendTransaction_
    extends UniffiError
    implements SendTransaction__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SendTransactionError';
    readonly tag = SendTransactionError_Tags.SendTransaction;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SendTransactionError', 'SendTransaction');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): SendTransaction_ {
      return new SendTransaction_(v0);
    }

    static instanceOf(obj: any): obj is SendTransaction_ {
      return obj.tag === SendTransactionError_Tags.SendTransaction;
    }

    static hasInner(obj: any): obj is SendTransaction_ {
      return SendTransaction_.instanceOf(obj);
    }

    static getInner(obj: SendTransaction_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type InvalidAddress__interface = {
    tag: SendTransactionError_Tags.InvalidAddress;
    inner: Readonly<[string]>;
  };

  class InvalidAddress_
    extends UniffiError
    implements InvalidAddress__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SendTransactionError';
    readonly tag = SendTransactionError_Tags.InvalidAddress;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SendTransactionError', 'InvalidAddress');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): InvalidAddress_ {
      return new InvalidAddress_(v0);
    }

    static instanceOf(obj: any): obj is InvalidAddress_ {
      return obj.tag === SendTransactionError_Tags.InvalidAddress;
    }

    static hasInner(obj: any): obj is InvalidAddress_ {
      return InvalidAddress_.instanceOf(obj);
    }

    static getInner(obj: InvalidAddress_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is SendTransactionError {
    return obj[uniffiTypeNameSymbol] === 'SendTransactionError';
  }

  return Object.freeze({
    instanceOf,
    SendTransaction: SendTransaction_,
    InvalidAddress: InvalidAddress_,
  });
})();

export type SendTransactionError = InstanceType<
  (typeof SendTransactionError)[keyof Omit<
    typeof SendTransactionError,
    'instanceOf'
  >]
>;

// FfiConverter for enum SendTransactionError
const FfiConverterTypeSendTransactionError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SendTransactionError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SendTransactionError.SendTransaction(
            FfiConverterString.read(from)
          );
        case 2:
          return new SendTransactionError.InvalidAddress(
            FfiConverterString.read(from)
          );
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SendTransactionError_Tags.SendTransaction: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SendTransactionError_Tags.InvalidAddress: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that SendTransactionError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SendTransactionError_Tags.SendTransaction: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SendTransactionError_Tags.InvalidAddress: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export interface PasskeyAuthenticator {
  signMessage(message: ArrayBuffer) /*throws*/ : ArrayBuffer;
}

export class PasskeyAuthenticatorImpl
  extends UniffiAbstractObject
  implements PasskeyAuthenticator
{
  readonly [uniffiTypeNameSymbol] = 'PasskeyAuthenticatorImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypePasskeyAuthenticatorImplObjectFactory.bless(pointer);
  }

  public signMessage(message: ArrayBuffer): ArrayBuffer /*throws*/ {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypePasskeyAuthenticatorError.lift.bind(
          FfiConverterTypePasskeyAuthenticatorError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_ffi_fn_method_passkeyauthenticator_sign_message(
            uniffiTypePasskeyAuthenticatorImplObjectFactory.clonePointer(this),
            FfiConverterArrayBuffer.lower(message),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypePasskeyAuthenticatorImplObjectFactory.pointer(this);
      uniffiTypePasskeyAuthenticatorImplObjectFactory.freePointer(pointer);
      uniffiTypePasskeyAuthenticatorImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is PasskeyAuthenticatorImpl {
    return uniffiTypePasskeyAuthenticatorImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypePasskeyAuthenticatorImplObjectFactory: UniffiObjectFactory<PasskeyAuthenticator> =
  {
    create(pointer: UnsafeMutableRawPointer): PasskeyAuthenticator {
      const instance = Object.create(PasskeyAuthenticatorImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'PasskeyAuthenticatorImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_passkeyauthenticator_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: PasskeyAuthenticator): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: PasskeyAuthenticator): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_ffi_fn_clone_passkeyauthenticator(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_ffi_fn_free_passkeyauthenticator(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is PasskeyAuthenticator {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'PasskeyAuthenticatorImpl'
      );
    },
  };
// FfiConverter for PasskeyAuthenticator
const FfiConverterTypePasskeyAuthenticator =
  new FfiConverterObjectWithCallbacks(
    uniffiTypePasskeyAuthenticatorImplObjectFactory
  );

// Add a vtavble for the callbacks that go in PasskeyAuthenticator.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfacePasskeyAuthenticator: {
  vtable: UniffiVTableCallbackInterfacePasskeyAuthenticator;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    signMessage: (uniffiHandle: bigint, message: Uint8Array) => {
      const uniffiMakeCall = (): ArrayBuffer => {
        const jsCallback =
          FfiConverterTypePasskeyAuthenticator.lift(uniffiHandle);
        return jsCallback.signMessage(FfiConverterArrayBuffer.lift(message));
      };
      const uniffiResult = UniffiResult.ready<Uint8Array>();
      const uniffiHandleSuccess = (obj: any) => {
        UniffiResult.writeSuccess(
          uniffiResult,
          FfiConverterArrayBuffer.lower(obj)
        );
      };
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCallWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ PasskeyAuthenticatorError.instanceOf,
        /*lowerError:*/ FfiConverterTypePasskeyAuthenticatorError.lower.bind(
          FfiConverterTypePasskeyAuthenticatorError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // PasskeyAuthenticator: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypePasskeyAuthenticator.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_ffi_fn_init_callback_vtable_passkeyauthenticator(
      uniffiCallbackInterfacePasskeyAuthenticator.vtable
    );
  },
};

export interface PasskeyAuthenticatorAsync {
  signMessage(
    message: ArrayBuffer,
    asyncOpts_?: { signal: AbortSignal }
  ) /*throws*/ : Promise<ArrayBuffer>;
}

export class PasskeyAuthenticatorAsyncImpl
  extends UniffiAbstractObject
  implements PasskeyAuthenticatorAsync
{
  readonly [uniffiTypeNameSymbol] = 'PasskeyAuthenticatorAsyncImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypePasskeyAuthenticatorAsyncImplObjectFactory.bless(pointer);
  }

  public async signMessage(
    message: ArrayBuffer,
    asyncOpts_?: { signal: AbortSignal }
  ): Promise<ArrayBuffer> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
      return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller,
        /*rustFutureFunc:*/ () => {
          return nativeModule().ubrn_uniffi_ffi_fn_method_passkeyauthenticatorasync_sign_message(
            uniffiTypePasskeyAuthenticatorAsyncImplObjectFactory.clonePointer(
              this
            ),
            FfiConverterArrayBuffer.lower(message)
          );
        },
        /*pollFunc:*/ nativeModule().ubrn_ffi_ffi_rust_future_poll_rust_buffer,
        /*cancelFunc:*/ nativeModule()
          .ubrn_ffi_ffi_rust_future_cancel_rust_buffer,
        /*completeFunc:*/ nativeModule()
          .ubrn_ffi_ffi_rust_future_complete_rust_buffer,
        /*freeFunc:*/ nativeModule().ubrn_ffi_ffi_rust_future_free_rust_buffer,
        /*liftFunc:*/ FfiConverterArrayBuffer.lift.bind(
          FfiConverterArrayBuffer
        ),
        /*liftString:*/ FfiConverterString.lift,
        /*asyncOpts:*/ asyncOpts_,
        /*errorHandler:*/ FfiConverterTypePasskeyAuthenticatorError.lift.bind(
          FfiConverterTypePasskeyAuthenticatorError
        )
      );
    } catch (__error: any) {
      if (uniffiIsDebug && __error instanceof Error) {
        __error.stack = __stack;
      }
      throw __error;
    }
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypePasskeyAuthenticatorAsyncImplObjectFactory.pointer(this);
      uniffiTypePasskeyAuthenticatorAsyncImplObjectFactory.freePointer(pointer);
      uniffiTypePasskeyAuthenticatorAsyncImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is PasskeyAuthenticatorAsyncImpl {
    return uniffiTypePasskeyAuthenticatorAsyncImplObjectFactory.isConcreteType(
      obj
    );
  }
}

const uniffiTypePasskeyAuthenticatorAsyncImplObjectFactory: UniffiObjectFactory<PasskeyAuthenticatorAsync> =
  {
    create(pointer: UnsafeMutableRawPointer): PasskeyAuthenticatorAsync {
      const instance = Object.create(PasskeyAuthenticatorAsyncImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'PasskeyAuthenticatorAsyncImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_passkeyauthenticatorasync_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: PasskeyAuthenticatorAsync): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: PasskeyAuthenticatorAsync): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_ffi_fn_clone_passkeyauthenticatorasync(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_ffi_fn_free_passkeyauthenticatorasync(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is PasskeyAuthenticatorAsync {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'PasskeyAuthenticatorAsyncImpl'
      );
    },
  };
// FfiConverter for PasskeyAuthenticatorAsync
const FfiConverterTypePasskeyAuthenticatorAsync =
  new FfiConverterObjectWithCallbacks(
    uniffiTypePasskeyAuthenticatorAsyncImplObjectFactory
  );

// Add a vtavble for the callbacks that go in PasskeyAuthenticatorAsync.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfacePasskeyAuthenticatorAsync: {
  vtable: UniffiVTableCallbackInterfacePasskeyAuthenticatorAsync;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    signMessage: (
      uniffiHandle: bigint,
      message: Uint8Array,
      uniffiFutureCallback: UniffiForeignFutureCompleteRustBuffer,
      uniffiCallbackData: bigint
    ) => {
      const uniffiMakeCall = async (
        signal: AbortSignal
      ): Promise<ArrayBuffer> => {
        const jsCallback =
          FfiConverterTypePasskeyAuthenticatorAsync.lift(uniffiHandle);
        return await jsCallback.signMessage(
          FfiConverterArrayBuffer.lift(message),
          { signal }
        );
      };
      const uniffiHandleSuccess = (returnValue: ArrayBuffer) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: FfiConverterArrayBuffer.lower(returnValue),
            callStatus: uniffiCaller.createCallStatus(),
          }
        );
      };
      const uniffiHandleError = (code: number, errorBuf: UniffiByteArray) => {
        uniffiFutureCallback(
          uniffiCallbackData,
          /* UniffiForeignFutureStructRustBuffer */ {
            returnValue: /*empty*/ new Uint8Array(0),
            // TODO create callstatus with error.
            callStatus: { code, errorBuf },
          }
        );
      };
      const uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*isErrorType:*/ PasskeyAuthenticatorError.instanceOf,
        /*lowerError:*/ FfiConverterTypePasskeyAuthenticatorError.lower.bind(
          FfiConverterTypePasskeyAuthenticatorError
        ),
        /*lowerString:*/ FfiConverterString.lower
      );
      return UniffiResult.success(uniffiForeignFuture);
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // PasskeyAuthenticatorAsync: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypePasskeyAuthenticatorAsync.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_ffi_fn_init_callback_vtable_passkeyauthenticatorasync(
      uniffiCallbackInterfacePasskeyAuthenticatorAsync.vtable
    );
  },
};

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_ffi_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (nativeModule().ubrn_uniffi_ffi_checksum_func_deploy_account() !== 40553) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ffi_checksum_func_deploy_account'
    );
  }
  if (
    nativeModule().ubrn_uniffi_ffi_checksum_func_deploy_account_with_unique_id() !==
    62711
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ffi_checksum_func_deploy_account_with_unique_id'
    );
  }
  if (nativeModule().ubrn_uniffi_ffi_checksum_func_fetch_account() !== 42263) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ffi_checksum_func_fetch_account'
    );
  }
  if (nativeModule().ubrn_uniffi_ffi_checksum_func_fund_account() !== 20619) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ffi_checksum_func_fund_account'
    );
  }
  if (
    nativeModule().ubrn_uniffi_ffi_checksum_func_generate_random_challenge() !==
    11583
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ffi_checksum_func_generate_random_challenge'
    );
  }
  if (
    nativeModule().ubrn_uniffi_ffi_checksum_func_get_account_by_user_id() !==
    26909
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ffi_checksum_func_get_account_by_user_id'
    );
  }
  if (nativeModule().ubrn_uniffi_ffi_checksum_func_get_balance() !== 46562) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ffi_checksum_func_get_balance'
    );
  }
  if (
    nativeModule().ubrn_uniffi_ffi_checksum_func_prepare_send_transaction() !==
    43366
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ffi_checksum_func_prepare_send_transaction'
    );
  }
  if (
    nativeModule().ubrn_uniffi_ffi_checksum_func_send_transaction() !== 44442
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ffi_checksum_func_send_transaction'
    );
  }
  if (
    nativeModule().ubrn_uniffi_ffi_checksum_func_send_transaction_async_signer() !==
    33905
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ffi_checksum_func_send_transaction_async_signer'
    );
  }
  if (
    nativeModule().ubrn_uniffi_ffi_checksum_method_passkeyauthenticator_sign_message() !==
    23237
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ffi_checksum_method_passkeyauthenticator_sign_message'
    );
  }
  if (
    nativeModule().ubrn_uniffi_ffi_checksum_method_passkeyauthenticatorasync_sign_message() !==
    43154
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_ffi_checksum_method_passkeyauthenticatorasync_sign_message'
    );
  }

  uniffiCallbackInterfacePasskeyAuthenticator.register();
  uniffiCallbackInterfacePasskeyAuthenticatorAsync.register();
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeAccount,
    FfiConverterTypeAccountBalance,
    FfiConverterTypeConfig,
    FfiConverterTypePasskeyAuthenticator,
    FfiConverterTypePasskeyAuthenticatorAsync,
    FfiConverterTypePasskeyContracts,
    FfiConverterTypePasskeyParameters,
    FfiConverterTypePreparedTransaction,
    FfiConverterTypeSendTransactionResult,
    FfiConverterTypeTransaction,
  },
});
